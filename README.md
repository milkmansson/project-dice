# Project DICE: A small Toit project showcasing MEMS capabilities

## History
A short while ago I began a project to create a digital random number generator/dice loaded with a choice of 'bad'
randomness and 'good' randomness, with the purpose of illustrating (to my customers) the impact to a simple scenario such as a well-known physical board game.
I'm not a professional developer, and eventually got stuck in the complexities of managing multithreading/multitasking in Arduino.  The project stalled.  
Since discovering Toit, its virutal machines, task/scheduling, etc, I realised I didn't have to solve those problems 
myself, or rely on complex libraries I couldn't troubleshoot.  This is a small Toit reincarnation of that project - code and ideas robbed from it, minus
the entropy/cryptography lesson.

## About this project
This is a digital dice, which uses motion data generated by moving it to create randomness for a dice roll.
To push the boundaries of what is possible, the intention of the device is not having any external buttons,
with any/all interactions (even configurations) performed by only by movement.

## Parts Required
I built this with parts I had on hand.  Construction with other hardware is definitely possible but may require some work.
- Toit - The platform needs to be installed on your ESP32, follow the instructions found here.
- ESP32 based DFRobot ESP32c6 Beetle (for the size constraints and very basic battery management built-in.)
- MPU6050 I2C based motion sensing device
- SSD1306 I2C based OLED Screen
- LED for indicating state (Optional)
- Connecting wires and other minor materials
- Lipo battery compatible with ESP32 board (Note polarity of commercial battery modules from overseas may not be the same as your ESP32 when they arrive!!)

## How it works (Aka State Machine)
| Stage | Interaction | Behind the scenes |
| - | - | - |
| 1 | Pick up the device to turn it 'On'. | Movement sense triggers interrupt waking ESP from deep sleep |
| 2 | Set it down so it learns which way is 'up' (the screen provides guidance). | Code examines movement and creates a calibration of 'up' |
| 3 | Shake up or down to select dice type (interactions via screen) | Using calibration and tuned timing/wait states, select from the menu. Obtain initial selection from storage, and save selected option to storage for later. |
| 4 | Set the device down for 15s to make the selection | Timer elapses, and selection (nim-roll/max-roll) selected |
| 5 | Shake the device, numbers adjust internally | Whilst waiting for the device to be set down, continutally consume data from the sensor, and roll together |
| 6 | When set down, display the 'roll' (plus distribution data, for interest) | Use a mathematical function to reduce collected data into a selection.  Display distribution data, and optionally save the distribution data to non volatile (flash) storage. |
| 7 | Wait.  Do another roll when moved (goto 5). | Use zero-motion-to-motion detection on the sensor to determine if shaking or resting |
| 8 | After 120s, go to deep sleep (off).  | Using monotonic time, wait for a (configurable) timer to expire and run the ESP32 command. |

## Versions

#### v1.0.0 This version
- Most features implemented.
- Menu selection incomplete, but underway.

#### To Do list: v(next)
- Provide better screen feedback about battery and charge.
- Have generated data sent to an online destination, for better statistical analysis.  (Include integration with Toit BLE Wifi provisioning package.)
- Integrate an SRAM chip (such as 47L16) instead of flash for saving data, to help save flash lifetime when collecting roll distribution data.
- Code integration with Artemis (use being optional) - for no other reason than to push whats possible.
